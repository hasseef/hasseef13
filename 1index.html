#!/usr/bin/env bash
set -e

ROOT="hasif"
echo "Scaffolding $ROOT (with Swagger + Full Auth) ..."
mkdir -p "$ROOT"/{apps/api,apps/web,packages/{ui,tsconfig},scripts}

############################################
# 0) .env + Docker + README
############################################
cat > "$ROOT/.env.example" << 'EOF'
DATABASE_URL="postgresql://hasif:hasif@localhost:5432/hasif?schema=public"

# API
JWT_SECRET="super-strong-secret"
JWT_REFRESH_SECRET="another-super-strong-secret"
APP_PORT=3001
APP_ORIGIN="http://localhost:3000"
ACCESS_TOKEN_TTL="15m"
REFRESH_TOKEN_TTL="7d"

# WEB
NEXT_PUBLIC_API_BASE="http://localhost:3001"
EOF

cat > "$ROOT/docker-compose.yml" << 'EOF'
version: "3.9"
services:
  db:
    image: postgres:16
    restart: unless-stopped
    environment:
      POSTGRES_USER: hasif
      POSTGRES_PASSWORD: hasif
      POSTGRES_DB: hasif
    ports: ["5432:5432"]
    volumes: [db_data:/var/lib/postgresql/data]

  pgadmin:
    image: dpage/pgadmin4:8
    restart: unless-stopped
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@hasif.local
      PGADMIN_DEFAULT_PASSWORD: admin
    ports: ["8081:80"]
    depends_on: [db]
volumes:
  db_data:
EOF

cat > "$ROOT/README.md" << 'EOF'
# HASIF Starter Kit (Swagger + Auth)
- API: NestJS + Prisma (PostgreSQL) + JWT (Access/Refresh) + RBAC + Swagger
- Web: Next.js 14
- CSV Export (أساس جاهز)
- Analytics/regions
## التشغيل السريع
1) docker compose -f hasif/docker-compose.yml up -d
2) cd hasif/apps/api && npm i && npx prisma generate && npx prisma migrate dev --name init && npm run seed && npm run start:dev
3) cd hasif/apps/web && npm i && npm run dev
Docs: http://localhost:3001/docs
EOF

############################################
# 1) packages/tsconfig
############################################
mkdir -p "$ROOT/packages/tsconfig"
cat > "$ROOT/packages/tsconfig/tsconfig.base.json" << 'EOF'
{
  "compilerOptions": {
    "target": "ES2021",
    "module": "CommonJS",
    "lib": ["ES2021"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}
EOF

############################################
# 2) API (Nest-ish hand scaffold)
############################################
cat > "$ROOT/apps/api/package.json" << 'EOF'
{
  "name": "@hasif/api",
  "version": "0.2.0",
  "type": "commonjs",
  "scripts": {
    "start": "ts-node src/main.ts",
    "start:dev": "ts-node-dev --respawn --transpile-only src/main.ts",
    "build": "tsc -p tsconfig.json",
    "seed": "ts-node --transpile-only src/seed.ts",
    "prisma:studio": "prisma studio"
  },
  "dependencies": {
    "@nestjs/common": "^10.0.0",
    "@nestjs/core": "^10.0.0",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/jwt": "^10.2.0",
    "@nestjs/passport": "^10.0.3",
    "@prisma/client": "^5.18.0",
    "@nestjs/swagger": "^7.3.1",
    "swagger-ui-express": "^5.0.1",
    "bcryptjs": "^2.4.3",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.1",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.1",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1"
  },
  "devDependencies": {
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.4.5",
    "prisma": "^5.18.0"
  }
}
EOF

cat > "$ROOT/apps/api/tsconfig.json" << 'EOF'
{
  "extends": "../../packages/tsconfig/tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "moduleResolution": "node",
    "baseUrl": "./",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true
  },
  "include": ["src/**/*"]
}
EOF

mkdir -p "$ROOT/apps/api/prisma"
cat > "$ROOT/apps/api/prisma/schema.prisma" << 'EOF'
generator client { provider = "prisma-client-js" }
datasource db { provider = "postgresql"; url = env("DATABASE_URL") }

model Organization {
  id        String   @id @default(cuid())
  code      String   @unique
  name      String
  type      OrgType
  region    String?
  users     User[]
  projects  Project[]
  challenges Challenge[]
  events    Event[]
  incubators Incubator[]
  wallet    Wallet?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
enum OrgType { gov private nonprofit university donor region dev_auth }

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  password  String
  role      Role
  orgId     String?
  org       Organization? @relation(fields: [orgId], references: [id])
  refreshTokenHash String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
enum Role { admin government development_authority region private nonprofit university donor individual }

model Challenge {
  id         String   @id @default(cuid())
  code       String   @unique
  title      String
  domain     String
  status     String   @default("open")
  ownerOrgId String
  ownerOrg   Organization @relation(fields: [ownerOrgId], references: [id])
  solutions  Solution[]
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Solution {
  id            String   @id @default(cuid())
  code          String   @unique
  summary       String
  score         Float?
  challengeId   String
  challenge     Challenge @relation(fields: [challengeId], references: [id])
  proposerOrgId String
  proposerOrg   Organization @relation(fields: [proposerOrgId], references: [id])
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Project {
  id           String   @id @default(cuid())
  code         String   @unique
  ownerOrgId   String
  ownerOrg     Organization @relation(fields: [ownerOrgId], references: [id])
  visionGoal   String
  status       String   @default("pending")
  budget       Int
  sourceSolutionId String?
  sourceSolution   Solution?   @relation(fields: [sourceSolutionId], references: [id])
  kpis         Kpi[]
  sponsorships Sponsorship[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Sponsorship {
  id        String   @id @default(cuid())
  targetType String
  targetId  String
  amount    Int
  donorOrgId String
  donorOrg   Organization @relation(fields: [donorOrgId], references: [id])
  status     String @default("approved")
  walletTx   Transaction?
  createdAt DateTime @default(now())
}

model Wallet {
  id        String   @id @default(cuid())
  orgId     String   @unique
  org       Organization @relation(fields: [orgId], references: [id])
  balance   Int       @default(0)
  txs       Transaction[]
}

model Transaction {
  id        String   @id @default(cuid())
  walletId  String
  wallet    Wallet    @relation(fields: [walletId], references: [id])
  type      TxType
  amount    Int
  ref       String?
  createdAt DateTime  @default(now())
}
enum TxType { credit debit }

model Event {
  id        String  @id @default(cuid())
  code      String  @unique
  orgId     String
  org       Organization @relation(fields: [orgId], references: [id])
  title     String
  date      DateTime
  speakers  String[]
  approvals String[]
  createdAt DateTime @default(now())
}

model Engagement {
  id        String  @id @default(cuid())
  type      EngagementType
  orgId     String
  org       Organization @relation(fields: [orgId], references: [id])
  hours     Int?
  fee       Int?
  createdAt DateTime @default(now())
}
enum EngagementType { volunteer training consulting }

model Media {
  id        String  @id @default(cuid())
  targetType String
  targetId  String
  headline  String?
  url       String?
  mime      String?
  storageKey String?
  createdAt DateTime @default(now())
}

model Incubator {
  id         String @id @default(cuid())
  name       String
  kind       String
  ownerOrgId String
  ownerOrg   Organization @relation(fields: [ownerOrgId], references: [id])
  createdAt  DateTime @default(now())
}

model Kpi {
  id          String @id @default(cuid())
  entityType  String
  entityId    String
  kpiKey      String
  value       Int
  period      String
  createdAt   DateTime @default(now())
}

model Audit {
  id        String @id @default(cuid())
  ts        DateTime @default(now())
  entity    String
  action    String
  details   Json
  userId    String?
}
EOF

mkdir -p "$ROOT/apps/api/src/{auth,decorators,guards,modules/common,modules/challenges,modules/solutions,modules/projects,modules/finance,modules/events,modules/engagements,modules/media,modules/incubators,modules/analytics,dto}"
############################################
# API bootstrap + Swagger
############################################
cat > "$ROOT/apps/api/src/main.ts" << 'EOF'
import 'dotenv/config';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import * as cors from 'cors';
import { ValidationPipe } from '@nestjs/common';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.use(cors({ origin: process.env.APP_ORIGIN || '*', credentials: true }));
  app.useGlobalPipes(new ValidationPipe({ whitelist: true, transform: true }));

  const cfg = new DocumentBuilder()
    .setTitle('HASIF API')
    .setDescription('HASIF Platform API (Swagger + Auth)')
    .setVersion('0.2.0')
    .addBearerAuth()
    .build();
  const doc = SwaggerModule.createDocument(app, cfg);
  SwaggerModule.setup('docs', app, doc, { swaggerOptions:{ persistAuthorization:true }});

  const port = Number(process.env.APP_PORT || 3001);
  await app.listen(port);
  console.log(`API listening on ${port} — Docs: http://localhost:${port}/docs`);
}
bootstrap();
EOF

cat > "$ROOT/apps/api/src/app.module.ts" << 'EOF'
import { Module } from '@nestjs/common';
import { PrismaService } from './modules/common/prisma.service';
import { AuthModule } from './auth/auth.module';
import { ChallengesModule } from './modules/challenges/challenges.module';
import { SolutionsModule } from './modules/solutions/solutions.module';
import { ProjectsModule } from './modules/projects/projects.module';
import { FinanceModule } from './modules/finance/finance.module';
import { EventsModule } from './modules/events/events.module';
import { EngagementsModule } from './modules/engagements/engagements.module';
import { MediaModule } from './modules/media/media.module';
import { IncubatorsModule } from './modules/incubators/incubators.module';
import { AnalyticsModule } from './modules/analytics/analytics.module';

@Module({
  imports: [AuthModule, ChallengesModule, SolutionsModule, ProjectsModule, FinanceModule, EventsModule, EngagementsModule, MediaModule, IncubatorsModule, AnalyticsModule],
  providers: [PrismaService],
})
export class AppModule {}
EOF

############################################
# Common services + CSV
############################################
cat > "$ROOT/apps/api/src/modules/common/prisma.service.ts" << 'EOF'
import { INestApplication, Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';
@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() { await this.$connect(); }
  async enableShutdownHooks(app: INestApplication) { this.$on('beforeExit', async () => { await app.close(); }); }
}
EOF

cat > "$ROOT/apps/api/src/modules/common/csv.ts" << 'EOF'
export function toCSV(rows:any[]):string{
  if(!rows?.length) return '';
  const headers = Array.from(new Set(rows.flatMap((r:any)=>Object.keys(r))));
  const esc=(s:any)=>'"'+String(s??'').replace(/"/g,'""')+'"';
  const lines=[headers.map(esc).join(',')];
  rows.forEach(r=>lines.push(headers.map(h=>esc((r as any)[h])).join(',')));
  return lines.join('\n');
}
EOF

############################################
# Auth (full): module, service, controller, guards
############################################
cat > "$ROOT/apps/api/src/decorators/current-user.decorator.ts" << 'EOF'
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
export const CurrentUser = createParamDecorator((data:unknown, ctx:ExecutionContext)=>{
  const req = ctx.switchToHttp().getRequest();
  return req.user;
});
EOF

cat > "$ROOT/apps/api/src/guards/jwt.guard.ts" << 'EOF'
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import * as jwt from 'jsonwebtoken';

@Injectable()
export class JwtGuard implements CanActivate {
  canActivate(ctx: ExecutionContext): boolean {
    const req = ctx.switchToHttp().getRequest();
    const h = req.headers['authorization'];
    if (!h || !String(h).startsWith('Bearer ')) return false;
    const token = String(h).slice(7);
    try {
      req.user = jwt.verify(token, process.env.JWT_SECRET || 'dev');
      return true;
    } catch { return false; }
  }
}
EOF

cat > "$ROOT/apps/api/src/guards/roles.guard.ts" << 'EOF'
import { CanActivate, ExecutionContext, Injectable, SetMetadata } from '@nestjs/common';
export const Roles = (...roles: string[]) => SetMetadata('roles', roles);
@Injectable()
export class RolesGuard implements CanActivate {
  canActivate(ctx: ExecutionContext): boolean {
    const handler = ctx.getHandler();
    const need: string[] = Reflect.getMetadata('roles', handler) || [];
    if (!need.length) return true;
    const req = ctx.switchToHttp().getRequest();
    const user = req.user;
    return user && need.includes(user.role);
  }
}
EOF

# DTOs
cat > "$ROOT/apps/api/src/dto/auth.dto.ts" << 'EOF'
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsOptional, IsString, MinLength } from 'class-validator';

export class RegisterDto {
  @ApiProperty() @IsEmail() email!: string;
  @ApiProperty() @IsString() @MinLength(3) name!: string;
  @ApiProperty() @IsString() @MinLength(6) password!: string;
  @ApiProperty({required:false}) @IsOptional() @IsString() role?: string;
  @ApiProperty({required:false, description:'Organization code'}) @IsOptional() @IsString() orgCode?: string;
}

export class LoginDto {
  @ApiProperty() @IsEmail() email!: string;
  @ApiProperty() @IsString() @MinLength(6) password!: string;
}

export class RefreshDto {
  @ApiProperty() @IsString() refreshToken!: string;
}
EOF

# Auth module/service/controller
cat > "$ROOT/apps/api/src/auth/auth.module.ts" << 'EOF'
import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { PrismaService } from '../modules/common/prisma.service';

@Module({
  providers:[AuthService,PrismaService],
  controllers:[AuthController],
  exports:[AuthService]
})
export class AuthModule {}
EOF

cat > "$ROOT/apps/api/src/auth/auth.service.ts" << 'EOF'
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PrismaService } from '../modules/common/prisma.service';
import * as bcrypt from 'bcryptjs';
import * as jwt from 'jsonwebtoken';

function signAccess(payload:any){
  return jwt.sign(payload, process.env.JWT_SECRET || 'dev', { expiresIn: process.env.ACCESS_TOKEN_TTL || '15m' });
}
function signRefresh(payload:any){
  return jwt.sign(payload, process.env.JWT_REFRESH_SECRET || 'dev2', { expiresIn: process.env.REFRESH_TOKEN_TTL || '7d' });
}

@Injectable()
export class AuthService {
  constructor(private prisma:PrismaService){}

  async register({email,name,password,role,orgCode}:{email:string,name:string,password:string,role?:string,orgCode?:string}){
    const hash = await bcrypt.hash(password, 10);
    const org = orgCode ? await this.prisma.organization.findUnique({ where:{ code:orgCode }}) : null;
    const user = await this.prisma.user.create({ data:{ email, name, password:hash, role:(role as any)||'individual', orgId: org?.id }});
    const tokens = await this.issueTokens(user);
    return { user: this.sanitize(user), ...tokens };
  }

  async validate(email:string, password:string){
    const user = await this.prisma.user.findUnique({ where:{ email }});
    if (!user) throw new UnauthorizedException('Invalid credentials');
    const ok = await bcrypt.compare(password, user.password);
    if (!ok) throw new UnauthorizedException('Invalid credentials');
    return user;
  }

  async login(email:string,password:string){
    const user = await this.validate(email,password);
    const tokens = await this.issueTokens(user);
    return { user: this.sanitize(user), ...tokens };
  }

  async refresh(userId:string, token:string){
    const user = await this.prisma.user.findUnique({ where:{ id:userId }});
    if(!user || !user.refreshTokenHash) throw new UnauthorizedException('No session');
    const valid = await bcrypt.compare(token, user.refreshTokenHash);
    if(!valid) throw new UnauthorizedException('Invalid refresh token');
    const accessToken = signAccess({ sub:user.id, email:user.email, role:user.role, orgId:user.orgId });
    return { accessToken };
  }

  private async issueTokens(user:any){
    const accessToken = signAccess({ sub:user.id, email:user.email, role:user.role, orgId:user.orgId });
    const refreshToken = signRefresh({ sub:user.id });
    const rHash = await bcrypt.hash(refreshToken, 10);
    await this.prisma.user.update({ where:{ id:user.id }, data:{ refreshTokenHash: rHash }});
    return { accessToken, refreshToken };
  }

  sanitize(u:any){ const { password, refreshTokenHash, ...rest } = u; return rest; }
}
EOF

cat > "$ROOT/apps/api/src/auth/auth.controller.ts" << 'EOF'
import { Body, Controller, Get, Post, UseGuards } from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';
import { AuthService } from './auth.service';
import { LoginDto, RefreshDto, RegisterDto } from '../dto/auth.dto';
import { JwtGuard } from '../guards/jwt.guard';
import { CurrentUser } from '../decorators/current-user.decorator';

@ApiTags('auth')
@Controller('auth')
export class AuthController {
  constructor(private svc:AuthService){}

  @Post('register')
  register(@Body() dto: RegisterDto){
    return this.svc.register(dto);
  }

  @Post('login')
  login(@Body() dto: LoginDto){
    return this.svc.login(dto.email, dto.password);
  }

  @Post('refresh')
  refresh(@Body() dto: RefreshDto, @CurrentUser() _u:any){
    // ملاحظة: عادة نقرأ الـ userId من الـ refreshJWT نفسه، هنا نتحقق فقط بالتوكن المخزن
    // لتبسيط الأمر: نفك التوكن ونجلب sub
    const jwt = require('jsonwebtoken');
    const payload = jwt.verify(dto.refreshToken, process.env.JWT_REFRESH_SECRET || 'dev2') as any;
    return this.svc.refresh(payload.sub, dto.refreshToken);
  }

  @Get('me')
  @UseGuards(JwtGuard)
  @ApiBearerAuth()
  me(@CurrentUser() u:any){ return u; }
}
EOF

############################################
# Seed (with hashed admin password)
############################################
cat > "$ROOT/apps/api/src/seed.ts" << 'EOF'
import { PrismaClient } from '@prisma/client';
import * as bcrypt from 'bcryptjs';
const prisma = new PrismaClient();

async function main(){
  const orgs = [
    { code:'org-gov-001', name:'وزارة التنمية', type:'gov', region:'الرياض' },
    { code:'org-priv-001', name:'شركة ألف', type:'private', region:'الرياض' },
    { code:'org-np-001', name:'جمعية بناء', type:'nonprofit', region:'الشرقية' },
    { code:'org-uni-001', name:'جامعة الملك المستقبل', type:'university', region:'مكة' },
    { code:'org-donor-001', name:'صندوق الأثر الوطني', type:'donor', region:'الرياض' },
    { code:'org-region-001', name:'إمارة منطقة الرياض', type:'region', region:'الرياض' },
    { code:'org-dev-001', name:'هيئة تطوير الرياض', type:'dev_auth', region:'الرياض' }
  ];
  for (const o of orgs) await prisma.organization.upsert({ where:{code:o.code}, update:o, create:o });

  const adminPass = await bcrypt.hash('Admin#12345', 10);
  await prisma.user.upsert({
    where:{ email:'admin@hasif.local' },
    update:{ password: adminPass, role:'admin' },
    create:{ email:'admin@hasif.local', name:'Admin', password: adminPass, role:'admin' }
  });

  const gov = await prisma.organization.findUnique({ where:{ code:'org-gov-001' }});
  const donor = await prisma.organization.findUnique({ where:{ code:'org-donor-001' }});
  if (donor) {
    const d = await prisma.wallet.findUnique({ where:{ orgId: donor.id }});
    if(!d) await prisma.wallet.create({ data:{ orgId: donor.id, balance: 1_000_000 }});
  }

  if (gov) {
    const ch1 = await prisma.challenge.upsert({ where:{ code:'ch-001' }, update:{}, create:{ code:'ch-001', title:'خفض فجوة المهارات الرقمية', domain:'تقنية', ownerOrgId: gov.id }});
    await prisma.solution.upsert({ where:{ code:'sol-001' }, update:{}, create:{ code:'sol-001', summary:'مسار تدريبي معتمد + تدريب تعاوني', proposerOrgId: gov.id, challengeId: ch1.id, score:4.5 }});
    await prisma.project.upsert({ where:{ code:'pr-001' }, update:{}, create:{ code:'pr-001', ownerOrgId: gov.id, visionGoal:'تحسين جودة الحياة', status:'in_progress', budget:250000 }});
    await prisma.event.upsert({ where:{ code:'ev-001' }, update:{}, create:{ code:'ev-001', orgId: gov.id, title:'منتدى المسؤولية الاجتماعية', date: new Date(), speakers:['د. نهى','م. سالم'], approvals:[] }});
  }

  console.log('Seed done. Admin: admin@hasif.local / Admin#12345');
}
main().finally(()=>prisma.$disconnect());
EOF

############################################
# Feature modules (reused from previous response) — shortened comments
############################################
cat > "$ROOT/apps/api/src/modules/challenges/challenges.module.ts" << 'EOF'
import { Module } from '@nestjs/common';
import { ChallengesService } from './challenges.service';
import { ChallengesController } from './challenges.controller';
import { PrismaService } from '../common/prisma.service';
@Module({ providers:[ChallengesService,PrismaService], controllers:[ChallengesController]})
export class ChallengesModule {}
EOF

cat > "$ROOT/apps/api/src/modules/challenges/challenges.service.ts" << 'EOF'
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../common/prisma.service';
@Injectable()
export class ChallengesService {
  constructor(private prisma:PrismaService){}
  async create(dto:any){
    const owner = await this.prisma.organization.findUnique({ where:{ code:dto.ownerCode || 'org-gov-001' }});
    return this.prisma.challenge.create({ data: { code:dto.code, title:dto.title, domain:dto.domain, ownerOrgId: owner?.id! }});
  }
  async list(q:{search?:string}) {
    const where = q.search ? { OR:[{ title:{ contains:q.search }},{ domain:{ contains:q.search }},{ code:{ contains:q.search }}] } : {};
    return this.prisma.challenge.findMany({ where, orderBy:{ createdAt:'desc' }, include:{ ownerOrg:true }});
  }
  async close(id:string){ return this.prisma.challenge.update({ where:{ id }, data:{ status:'closed' } }); }
}
EOF

cat > "$ROOT/apps/api/src/modules/challenges/challenges.controller.ts" << 'EOF'
import { Controller, Get, Post, Body, Patch, Param, Query, Res, UseGuards } from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';
import { ChallengesService } from './challenges.service';
import { toCSV } from '../common/csv';
import { JwtGuard } from '../../guards/jwt.guard';
import { Roles, RolesGuard } from '../../guards/roles.guard';

@ApiTags('challenges')
@Controller('challenges')
@UseGuards(JwtGuard, RolesGuard)
@ApiBearerAuth()
export class ChallengesController {
  constructor(private svc:ChallengesService){}
  @Post() @Roles('government','development_authority','admin')
  create(@Body() dto:any){ return this.svc.create(dto); }
  @Get() findAll(@Query() q:{search?:string}){ return this.svc.list(q); }
  @Patch(':id/close') @Roles('government','admin')
  close(@Param('id') id:string){ return this.svc.close(id); }

  @Post('/csv/export')
  async exportCsv(@Res() res:any){
    const rows = await this.svc.list({});
    const csv = toCSV(rows.map(r=>({id:r.id,code:r.code,title:r.title,domain:r.domain,status:r.status,owner:r.ownerOrg?.code})));
    res.setHeader('Content-Type','text/csv; charset=utf-8');
    res.setHeader('Content-Disposition','attachment; filename="challenges.csv"');
    res.send(csv);
  }
}
EOF

# Solutions
cat > "$ROOT/apps/api/src/modules/solutions/solutions.module.ts" << 'EOF'
import { Module } from '@nestjs/common';
import { SolutionsService } from './solutions.service';
import { SolutionsController } from './solutions.controller';
import { PrismaService } from '../common/prisma.service';
@Module({ providers:[SolutionsService,PrismaService], controllers:[SolutionsController]})
export class SolutionsModule {}
EOF

cat > "$ROOT/apps/api/src/modules/solutions/solutions.service.ts" << 'EOF'
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../common/prisma.service';
@Injectable()
export class SolutionsService {
  constructor(private prisma:PrismaService){}
  async create(dto:any){
    const proposer = await this.prisma.organization.findUnique({ where:{ code:dto.proposerCode || 'org-priv-001' }});
    const challenge = await this.prisma.challenge.findUnique({ where:{ code:dto.challengeCode }});
    return this.prisma.solution.create({ data:{
      code:dto.code, summary:dto.summary, score: dto.score? Number(dto.score): null,
      proposerOrgId: proposer?.id!, challengeId: challenge?.id!
    }});
  }
  async list(q:{search?:string}){
    const where = q.search ? { OR:[{ summary:{ contains:q.search }},{ code:{ contains:q.search }}] } : {};
    return this.prisma.solution.findMany({ where, orderBy:{ createdAt:'desc' }, include:{ proposerOrg:true, challenge:true }});
  }
}
EOF

cat > "$ROOT/apps/api/src/modules/solutions/solutions.controller.ts" << 'EOF'
import { Controller, Get, Post, Body, Query, Res, UseGuards } from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';
import { SolutionsService } from './solutions.service';
import { toCSV } from '../common/csv';
import { JwtGuard } from '../../guards/jwt.guard';
import { Roles, RolesGuard } from '../../guards/roles.guard';

@ApiTags('solutions')
@Controller('solutions')
@UseGuards(JwtGuard, RolesGuard)
@ApiBearerAuth()
export class SolutionsController {
  constructor(private svc:SolutionsService){}
  @Post() @Roles('private','nonprofit','university','individual','admin')
  create(@Body() dto:any){ return this.svc.create(dto); }
  @Get() findAll(@Query() q:{search?:string}){ return this.svc.list(q); }

  @Post('/csv/export')
  async exportCsv(@Res() res:any){
    const rows = await this.svc.list({});
    const csv = toCSV(rows.map(r=>({id:r.id,code:r.code,summary:r.summary,score:r.score,challenge:r.challenge?.code,proposer:r.proposerOrg?.code})));
    res.setHeader('Content-Type','text/csv; charset=utf-8');
    res.setHeader('Content-Disposition','attachment; filename="solutions.csv"');
    res.send(csv);
  }
}
EOF

# Projects
cat > "$ROOT/apps/api/src/modules/projects/projects.module.ts" << 'EOF'
import { Module } from '@nestjs/common';
import { ProjectsService } from './projects.service';
import { ProjectsController } from './projects.controller';
import { PrismaService } from '../common/prisma.service';
@Module({ providers:[ProjectsService,PrismaService], controllers:[ProjectsController]})
export class ProjectsModule {}
EOF

cat > "$ROOT/apps/api/src/modules/projects/projects.service.ts" << 'EOF'
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../common/prisma.service';
@Injectable()
export class ProjectsService {
  constructor(private prisma:PrismaService){}
  async create(dto:any){
    const owner = await this.prisma.organization.findUnique({ where:{ code:dto.ownerCode || 'org-gov-001' }});
    const src = dto.sourceSolutionCode ? await this.prisma.solution.findUnique({ where:{ code:dto.sourceSolutionCode }}) : null;
    return this.prisma.project.create({ data:{
      code:dto.code, ownerOrgId: owner?.id!, visionGoal:dto.visionGoal, budget: Number(dto.budget||0),
      status: dto.status || 'pending', sourceSolutionId: src?.id || null
    }});
  }
  async list(q:{search?:string}){
    const where = q.search ? { OR:[{ code:{ contains:q.search }},{ visionGoal:{ contains:q.search }}] } : {};
    return this.prisma.project.findMany({ where, include:{ ownerOrg:true, sourceSolution:true }, orderBy:{ createdAt:'desc' }});
  }
  async updateStatus(code:string,status:string){
    return this.prisma.project.update({ where:{ code }, data:{ status }});
  }
}
EOF

cat > "$ROOT/apps/api/src/modules/projects/projects.controller.ts" << 'EOF'
import { Controller, Get, Post, Patch, Param, Body, Query, Res, UseGuards } from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';
import { ProjectsService } from './projects.service';
import { toCSV } from '../common/csv';
import { JwtGuard } from '../../guards/jwt.guard';
import { Roles, RolesGuard } from '../../guards/roles.guard';

@ApiTags('projects')
@Controller('projects')
@UseGuards(JwtGuard, RolesGuard)
@ApiBearerAuth()
export class ProjectsController {
  constructor(private svc:ProjectsService){}
  @Post() @Roles('government','development_authority','admin')
  create(@Body() dto:any){ return this.svc.create(dto); }
  @Get() findAll(@Query() q:{search?:string}){ return this.svc.list(q); }
  @Patch(':code/status') @Roles('government','development_authority','admin')
  upd(@Param('code') code:string, @Body() b:{status:string}){ return this.svc.updateStatus(code,b.status); }

  @Post('/csv/export')
  async exportCsv(@Res() res:any){
    const rows = await this.svc.list({});
    const csv = toCSV(rows.map(r=>({code:r.code,owner:r.ownerOrg?.code,goal:r.visionGoal,budget:r.budget,status:r.status,source:r.sourceSolution?.code || ''})));
    res.setHeader('Content-Type','text/csv; charset=utf-8');
    res.setHeader('Content-Disposition','attachment; filename="projects.csv"');
    res.send(csv);
  }
}
EOF

# Finance (wallet+sponsorships)
cat > "$ROOT/apps/api/src/modules/finance/finance.module.ts" << 'EOF'
import { Module } from '@nestjs/common';
import { FinanceService } from './finance.service';
import { FinanceController } from './finance.controller';
import { PrismaService } from '../common/prisma.service';
@Module({ providers:[FinanceService,PrismaService], controllers:[FinanceController]})
export class FinanceModule {}
EOF

cat > "$ROOT/apps/api/src/modules/finance/finance.service.ts" << 'EOF'
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../common/prisma.service';
@Injectable()
export class FinanceService {
  constructor(private prisma:PrismaService){}
  async wallet(orgCode:string){
    const org = await this.prisma.organization.findUnique({ where:{ code:orgCode }});
    if (!org) return { balance:0 };
    let w = await this.prisma.wallet.findUnique({ where:{ orgId: org.id }});
    if(!w) w = await this.prisma.wallet.create({ data:{ orgId: org.id, balance:0 }});
    return w;
  }
  async tx(orgCode:string, type:'credit'|'debit', amount:number, ref?:string){
    const w = await this.wallet(orgCode);
    const bal = type==='credit' ? w.balance+amount : w.balance-amount;
    await this.prisma.wallet.update({ where:{ id:w.id }, data:{ balance: bal }});
    return this.prisma.transaction.create({ data:{ walletId: w.id, type, amount, ref }});
  }
  async listSponsorships(){ return this.prisma.sponsorship.findMany({ orderBy:{ createdAt:'desc' }}) }
  async addSponsorship(dto:any){
    return this.prisma.sponsorship.create({ data:{
      targetType:dto.targetType, targetId:dto.targetId, donorOrgId:(await this.prisma.organization.findUnique({ where:{ code:dto.donorCode }}))!.id,
      amount:Number(dto.amount||0), status:'approved'
    }});
  }
}
EOF

cat > "$ROOT/apps/api/src/modules/finance/finance.controller.ts" << 'EOF'
import { Controller, Get, Post, Body, Query, UseGuards } from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';
import { FinanceService } from './finance.service';
import { JwtGuard } from '../../guards/jwt.guard';
import { Roles, RolesGuard } from '../../guards/roles.guard';

@ApiTags('finance')
@Controller('finance')
@UseGuards(JwtGuard, RolesGuard)
@ApiBearerAuth()
export class FinanceController {
  constructor(private svc:FinanceService){}
  @Get('wallet') @Roles('donor','private','nonprofit','government','development_authority','admin')
  getWallet(@Query('org') org:string){ return this.svc.wallet(org); }
  @Post('tx') @Roles('donor','admin')
  tx(@Body() b:{org:string,type:'credit'|'debit',amount:number,ref?:string}){ return this.svc.tx(b.org,b.type,Number(b.amount),b.ref); }
  @Get('sponsorships') @Roles('donor','government','development_authority','admin')
  list(){ return this.svc.listSponsorships(); }
  @Post('sponsorships') @Roles('donor','admin')
  add(@Body() b:any){ return this.svc.addSponsorship(b); }
}
EOF

# Events
cat > "$ROOT/apps/api/src/modules/events/events.module.ts" << 'EOF'
import { Module } from '@nestjs/common';
import { EventsService } from './events.service';
import { EventsController } from './events.controller';
import { PrismaService } from '../common/prisma.service';
@Module({ providers:[EventsService,PrismaService], controllers:[EventsController]})
export class EventsModule {}
EOF

cat > "$ROOT/apps/api/src/modules/events/events.service.ts" << 'EOF'
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../common/prisma.service';
@Injectable()
export class EventsService {
  constructor(private prisma:PrismaService){}
  async create(dto:any){
    const org = await this.prisma.organization.findUnique({ where:{ code:dto.orgCode || 'org-priv-001' }});
    return this.prisma.event.create({ data:{ code:dto.code, orgId: org?.id!, title:dto.title, date:new Date(dto.date), speakers: dto.speakers || [], approvals: [] }});
  }
  async list(q:{search?:string}) {
    const where = q.search ? { OR:[ { title:{ contains:q.search }}, { code:{ contains:q.search }} ] } : {};
    return this.prisma.event.findMany({ where, orderBy:{ date:'desc' }, include:{ org:true }});
  }
}
EOF

cat > "$ROOT/apps/api/src/modules/events/events.controller.ts" << 'EOF'
import { Controller, Get, Post, Body, Query, Res, UseGuards } from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';
import { EventsService } from './events.service';
import { toCSV } from '../common/csv';
import { JwtGuard } from '../../guards/jwt.guard';
import { Roles, RolesGuard } from '../../guards/roles.guard';

@ApiTags('events')
@Controller('events')
@UseGuards(JwtGuard, RolesGuard)
@ApiBearerAuth()
export class EventsController {
  constructor(private svc:EventsService){}
  @Post() @Roles('private','nonprofit','university','government','development_authority','admin')
  create(@Body() dto:any){ return this.svc.create(dto); }
  @Get() findAll(@Query() q:{search?:string}){ return this.svc.list(q); }

  @Post('/csv/export')
  async exportCsv(@Res() res:any){
    const rows = await this.svc.list({});
    const csv = toCSV(rows.map(r=>({code:r.code,title:r.title,date:r.date,org:r.org?.code,speakers:r.speakers?.join('|')})));
    res.setHeader('Content-Type','text/csv; charset=utf-8');
    res.setHeader('Content-Disposition','attachment; filename="events.csv"');
    res.send(csv);
  }
}
EOF

# Engagements
cat > "$ROOT/apps/api/src/modules/engagements/engagements.module.ts" << 'EOF'
import { Module } from '@nestjs/common';
import { EngagementsService } from './engagements.service';
import { EngagementsController } from './engagements.controller';
import { PrismaService } from '../common/prisma.service';
@Module({ providers:[EngagementsService,PrismaService], controllers:[EngagementsController]})
export class EngagementsModule {}
EOF

cat > "$ROOT/apps/api/src/modules/engagements/engagements.service.ts" << 'EOF'
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../common/prisma.service';
@Injectable()
export class EngagementsService {
  constructor(private prisma:PrismaService){}
  async create(dto:any){
    const org = await this.prisma.organization.findUnique({ where:{ code:dto.orgCode || 'org-np-001' }});
    return this.prisma.engagement.create({ data:{ type: dto.type, orgId: org?.id!, hours: dto.hours? Number(dto.hours): null, fee: dto.fee? Number(dto.fee): null }});
  }
  async list(){ return this.prisma.engagement.findMany({ orderBy:{ createdAt:'desc' }, include:{ org:true }}); }
}
EOF

cat > "$ROOT/apps/api/src/modules/engagements/engagements.controller.ts" << 'EOF'
import { Controller, Get, Post, Body, Res, UseGuards } from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';
import { EngagementsService } from './engagements.service';
import { toCSV } from '../common/csv';
import { JwtGuard } from '../../guards/jwt.guard';
import { Roles, RolesGuard } from '../../guards/roles.guard';

@ApiTags('engagements')
@Controller('engagements')
@UseGuards(JwtGuard, RolesGuard)
@ApiBearerAuth()
export class EngagementsController {
  constructor(private svc:EngagementsService){}
  @Post() @Roles('nonprofit','university','private','individual','government','admin')
  create(@Body() dto:any){ return this.svc.create(dto); }
  @Get() findAll(){ return this.svc.list(); }

  @Post('/csv/export')
  async exportCsv(@Res() res:any){
    const rows = await this.svc.list();
    const csv = toCSV(rows.map(r=>({id:r.id,type:r.type,org:r.org?.code,hours:r.hours||'',fee:r.fee||''})));
    res.setHeader('Content-Type','text/csv; charset=utf-8');
    res.setHeader('Content-Disposition','attachment; filename="engagements.csv"');
    res.send(csv);
  }
}
EOF

# Media
cat > "$ROOT/apps/api/src/modules/media/media.module.ts" << 'EOF'
import { Module } from '@nestjs/common';
import { MediaService } from './media.service';
import { MediaController } from './media.controller';
import { PrismaService } from '../common/prisma.service';
@Module({ providers:[MediaService,PrismaService], controllers:[MediaController]})
export class MediaModule {}
EOF

cat > "$ROOT/apps/api/src/modules/media/media.service.ts" << 'EOF'
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../common/prisma.service';
@Injectable()
export class MediaService {
  constructor(private prisma:PrismaService){}
  async create(dto:any){
    return this.prisma.media.create({ data:{
      targetType:dto.targetType, targetId:dto.targetId, headline:dto.headline, url:dto.url, mime:dto.mime || null, storageKey: null
    }});
  }
  async list(){ return this.prisma.media.findMany({ orderBy:{ createdAt:'desc' }}); }
}
EOF

cat > "$ROOT/apps/api/src/modules/media/media.controller.ts" << 'EOF'
import { Controller, Get, Post, Body, Res, UseGuards } from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';
import { MediaService } from './media.service';
import { toCSV } from '../common/csv';
import { JwtGuard } from '../../guards/jwt.guard';
import { Roles, RolesGuard } from '../../guards/roles.guard';

@ApiTags('media')
@Controller('media')
@UseGuards(JwtGuard, RolesGuard)
@ApiBearerAuth()
export class MediaController {
  constructor(private svc:MediaService){}
  @Post() @Roles('government','private','nonprofit','university','development_authority','region','admin')
  create(@Body() dto:any){ return this.svc.create(dto); }
  @Get() list(){ return this.svc.list(); }

  @Post('/csv/export')
  async exportCsv(@Res() res:any){
    const rows = await this.svc.list();
    const csv = toCSV(rows.map(r=>({id:r.id,target:`${r.targetType}:${r.targetId}`,headline:r.headline||'',url:r.url||''})));
    res.setHeader('Content-Type','text/csv; charset=utf-8');
    res.setHeader('Content-Disposition','attachment; filename="media.csv"');
    res.send(csv);
  }
}
EOF

# Incubators
cat > "$ROOT/apps/api/src/modules/incubators/incubators.module.ts" << 'EOF'
import { Module } from '@nestjs/common';
import { IncubatorsService } from './incubators.service';
import { IncubatorsController } from './incubators.controller';
import { PrismaService } from '../common/prisma.service';
@Module({ providers:[IncubatorsService,PrismaService], controllers:[IncubatorsController]})
export class IncubatorsModule {}
EOF

cat > "$ROOT/apps/api/src/modules/incubators/incubators.service.ts" << 'EOF'
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../common/prisma.service';
@Injectable()
export class IncubatorsService {
  constructor(private prisma:PrismaService){}
  async create(dto:any){
    const owner = await this.prisma.organization.findUnique({ where:{ code:dto.ownerCode || 'org-dev-001' }});
    return this.prisma.incubator.create({ data:{ name:dto.name, kind:dto.kind, ownerOrgId: owner?.id! }});
  }
  async list(){ return this.prisma.incubator.findMany({ include:{ ownerOrg:true }, orderBy:{ createdAt:'desc' }}); }
}
EOF

cat > "$ROOT/apps/api/src/modules/incubators/incubators.controller.ts" << 'EOF'
import { Controller, Get, Post, Body, Res, UseGuards } from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';
import { IncubatorsService } from './incubators.service';
import { toCSV } from '../common/csv';
import { JwtGuard } from '../../guards/jwt.guard';
import { Roles, RolesGuard } from '../../guards/roles.guard';

@ApiTags('incubators')
@Controller('incubators')
@UseGuards(JwtGuard, RolesGuard)
@ApiBearerAuth()
export class IncubatorsController {
  constructor(private svc:IncubatorsService){}
  @Post() @Roles('development_authority','university','private','nonprofit','admin')
  create(@Body() dto:any){ return this.svc.create(dto); }
  @Get() findAll(){ return this.svc.list(); }

  @Post('/csv/export')
  async exportCsv(@Res() res:any){
    const rows = await this.svc.list();
    const csv = toCSV(rows.map(r=>({id:r.id,name:r.name,kind:r.kind,owner:r.ownerOrg?.code})));
    res.setHeader('Content-Type','text/csv; charset=utf-8');
    res.setHeader('Content-Disposition','attachment; filename="incubators.csv"');
    res.send(csv);
  }
}
EOF

# Analytics
cat > "$ROOT/apps/api/src/modules/analytics/analytics.module.ts" << 'EOF'
import { Module } from '@nestjs/common';
import { AnalyticsService } from './analytics.service';
import { AnalyticsController } from './analytics.controller';
import { PrismaService } from '../common/prisma.service';
@Module({ providers:[AnalyticsService,PrismaService], controllers:[AnalyticsController]})
export class AnalyticsModule {}
EOF

cat > "$ROOT/apps/api/src/modules/analytics/analytics.service.ts" << 'EOF'
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../common/prisma.service';
@Injectable()
export class AnalyticsService {
  constructor(private prisma:PrismaService){}
  async regions() {
    const orgs = await this.prisma.organization.findMany();
    const idx = new Map(orgs.map(o=>[o.id,o]));
    const agg:any = {};
    const getRegion=(orgId:string)=> idx.get(orgId)?.region || 'غير محدد';

    const projs = await this.prisma.project.findMany();
    projs.forEach(p=>{
      const r=getRegion(p.ownerOrgId);
      agg[r] ||= { projects:0,funded:0,budget:0,solutions:0,challenges:0,events:0,engagements:0 };
      agg[r].projects++; agg[r].budget += p.budget||0; if(['funded','completed'].includes(p.status)) agg[r].funded++;
    });

    const chs = await this.prisma.challenge.findMany(); chs.forEach(c=>{ const r=getRegion(c.ownerOrgId); agg[r] ||= { projects:0,funded:0,budget:0,solutions:0,challenges:0,events:0,engagements:0 }; agg[r].challenges++; });
    const sols = await this.prisma.solution.findMany({ include:{ proposerOrg:true }});
    sols.forEach(s=>{ const r=s.proposerOrg?.region || 'غير محدد'; agg[r] ||= { projects:0,funded:0,budget:0,solutions:0,challenges:0,events:0,engagements:0 }; agg[r].solutions++; });
    const evs = await this.prisma.event.findMany({ include:{ org:true }}); evs.forEach(e=>{ const r=e.org?.region || 'غير محدد'; agg[r] ||= { projects:0,funded:0,budget:0,solutions:0,challenges:0,events:0,engagements:0 }; agg[r].events++; });
    const engs = await this.prisma.engagement.findMany({ include:{ org:true }}); engs.forEach(e=>{ const r=e.org?.region || 'غير محدد'; agg[r] ||= { projects:0,funded:0,budget:0,solutions:0,challenges:0,events:0,engagements:0 }; agg[r].engagements++; });
    return agg;
  }
}
EOF

cat > "$ROOT/apps/api/src/modules/analytics/analytics.controller.ts" << 'EOF'
import { Controller, Get, UseGuards } from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';
import { AnalyticsService } from './analytics.service';
import { JwtGuard } from '../../guards/jwt.guard';

@ApiTags('analytics')
@Controller('analytics')
@UseGuards(JwtGuard)
@ApiBearerAuth()
export class AnalyticsController {
  constructor(private svc:AnalyticsService){}
  @Get('regions') get(){ return this.svc.regions(); }
}
EOF

############################################
# 3) WEB (Next.js minimal remains same)
############################################
cat > "$ROOT/apps/web/package.json" << 'EOF'
{
  "name": "@hasif/web",
  "version": "0.2.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3000",
    "build": "next build",
    "start": "next start -p 3000"
  },
  "dependencies": {
    "next": "14.2.5",
    "react": "18.3.1",
    "react-dom": "18.3.1"
  },
  "devDependencies": {
    "typescript": "^5.4.5",
    "@types/node": "^20.11.30",
    "@types/react": "^18.2.66"
  }
}
EOF

cat > "$ROOT/apps/web/tsconfig.json" << 'EOF'
{
  "extends": "../../packages/tsconfig/tsconfig.base.json",
  "compilerOptions": { "jsx": "preserve", "moduleResolution":"node", "baseUrl":"." },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"]
}
EOF

cat > "$ROOT/apps/web/next.config.mjs" << 'EOF'
/** @type {import('next').NextConfig} */
const nextConfig = { reactStrictMode: true };
export default nextConfig;
EOF

cat > "$ROOT/apps/web/next-env.d.ts" << 'EOF'
/// <reference types="next" />
/// <reference types="next/image-types/global" />
EOF

mkdir -p "$ROOT/apps/web/app"
cat > "$ROOT/apps/web/app/layout.tsx" << 'EOF'
export const metadata = { title: 'HASIF', description: 'HASIF Starter Web' };
export default function RootLayout({children}:{children:React.ReactNode}) {
  return (<html lang="ar" dir="rtl"><body style={{fontFamily:'system-ui',margin:0,background:'#f7f6f1'}}>
    <header style={{background:'#0b5b34',color:'#fff',padding:'12px 16px',borderBottom:'4px solid #c9a227'}}>
      <strong>منصة حصيف — واجهة مبدئية</strong>
      <a href="http://localhost:3001/docs" target="_blank" style={{float:'left',color:'#fff'}}>Swagger</a>
    </header>
    <main style={{maxWidth:1100,margin:'0 auto',padding:16}}>{children}</main>
  </body></html>);
}
EOF

cat > "$ROOT/apps/web/app/page.tsx" << 'EOF'
'use client';
import { useEffect, useState } from 'react';
const API = process.env.NEXT_PUBLIC_API_BASE || 'http://localhost:3001';

export default function Home(){
  const [projects,setProjects]=useState<any[]>([]);
  const [regions,setRegions]=useState<any>({});
  const [q,setQ]=useState('');
  const [token,setToken]=useState<string>('');

  useEffect(()=>{
    // تسجيل دخول افتراضي لتجربة الحماية
    (async()=>{
      const r=await fetch(`${API}/auth/login`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({email:'admin@hasif.local',password:'Admin#12345'})});
      const data=await r.json(); setToken(data.accessToken);
    })();
  },[]);

  useEffect(()=>{ if(!token) return; fetch(`${API}/projects?search=${encodeURIComponent(q)}`,{headers:{Authorization:`Bearer ${token}`}}).then(r=>r.json()).then(setProjects); },[q,token]);
  useEffect(()=>{ if(!token) return; fetch(`${API}/analytics/regions`,{headers:{Authorization:`Bearer ${token}`}}).then(r=>r.json()).then(setRegions); },[token]);

  return (
    <div>
      <h1 style={{fontSize:22,fontWeight:800}}>لوحة مختصرة</h1>
      <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:12}}>
        <div style={{background:'#fff',border:'1px solid #e5e7eb',borderRadius:12,padding:12}}>
          <h3>المشاريع</h3>
          <input placeholder="بحث..." value={q} onChange={e=>setQ(e.target.value)} style={{padding:8,border:'1px solid #e5e7eb',borderRadius:8,marginBottom:8}}/>
          <table style={{width:'100%',borderCollapse:'collapse'}}>
            <thead><tr><th>المعرّف</th><th>الجهة</th><th>الهدف</th><th>الميزانية</th><th>الحالة</th></tr></thead>
            <tbody>
              {projects.map((p:any)=>(
                <tr key={p.id} style={{borderTop:'1px solid #e5e7eb'}}>
                  <td>{p.code}</td><td>{p.ownerOrg?.code}</td><td>{p.visionGoal}</td><td>{p.budget?.toLocaleString?.()}</td><td>{p.status}</td>
                </tr>
              ))}
            </tbody>
          </table>
          <div style={{marginTop:8}}>
            <a href={`${API}/projects/csv/export`} target="_blank" style={{border:'1px solid #0b5b34',padding:'6px 10px',borderRadius:8}}>تصدير CSV</a>
          </div>
        </div>
        <div style={{background:'#fff',border:'1px solid #e5e7eb',borderRadius:12,padding:12}}>
          <h3>مقارنة المناطق</h3>
          <ul>
            {Object.keys(regions).map(k=>(
              <li key={k}>{k}: مشاريع {regions[k].projects} — ممول {regions[k].funded} — ميزانية {(regions[k].budget/1000|0)} ألف</li>
            ))}
          </ul>
        </div>
      </div>
    </div>
  );
}
EOF

echo "Scaffold complete at $ROOT/"
cat << 'TXT'

==============================
تشغيل سريع (بعد إنشاء الملفات)
==============================
1) قاعدة البيانات:
   docker compose -f hasif/docker-compose.yml up -d

2) API:
   cd hasif/apps/api
   cp ../../.env.example .env
   npm i
   npx prisma generate
   npx prisma migrate dev --name init
   npm run seed
   npm run start:dev
   -> Swagger: http://localhost:3001/docs

3) الواجهة:
   cd ../../web
   cp ../../.env.example .env
   npm i
   npm run dev
   -> http://localhost:3000

بيانات دخول تجريبية:
  email: admin@hasif.local
  pass : Admin#12345

ملاحظات:
- Refresh Token يُعاد من /auth/login ويُخزَّن هاشه في User.refreshTokenHash.
- لتجديد التوكن: POST /auth/refresh { refreshToken } -> accessToken جديد.
- الحماية عبر @UseGuards(JwtGuard, RolesGuard) ومسارات مقيّدة بـ @Roles(...).
- يمكنك تعديل سياسات الأدوار لكل وحدة حسب الحاجة.
TXT
